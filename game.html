<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Transcendence Game</title>
	<style>
		body {
			margin: 0;
			padding: 20px;
			font-family: 'Courier New', monospace;
			background: #1a1a1a;
			color: #00ff00;
			display: flex;
			flex-direction: column;
			align-items: center;
			min-height: 100vh;
		}

		.container {
			max-width: 1200px;
			width: 100%;
		}

		.header {
			text-align: center;
			margin-bottom: 20px;
		}

		.game-area {
			display: flex;
			gap: 20px;
			justify-content: center;
			align-items: flex-start;
		}

		.lobby-panel {
			width: 300px;
			background: #2a2a2a;
			border: 2px solid #00ff00;
			border-radius: 8px;
			padding: 15px;
		}

		.game-canvas-container {
			position: relative;
		}

		#gameCanvas {
			border: 2px solid #00ff00;
			border-radius: 8px;
			background: #000;
			cursor: none;
		}

		.overlay {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			text-align: center;
			font-size: 24px;
			font-weight: bold;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
		}

		.countdown {
			color: #ff4444;
			font-size: 48px;
		}

		.room-list {
			max-height: 300px;
			overflow-y: auto;
			margin: 10px 0;
		}

		.room-item {
			background: #3a3a3a;
			border: 1px solid #555;
			margin: 5px 0;
			padding: 10px;
			border-radius: 4px;
			cursor: pointer;
			transition: background 0.2s;
		}

		.room-item:hover {
			background: #4a4a4a;
		}

		.room-item.current {
			border-color: #00ff00;
			background: #1a3a1a;
		}

		.controls {
			margin: 10px 0;
		}

		.btn {
			background: #2a2a2a;
			border: 2px solid #00ff00;
			color: #00ff00;
			padding: 8px 16px;
			margin: 5px;
			border-radius: 4px;
			cursor: pointer;
			font-family: inherit;
			transition: all 0.2s;
		}

		.btn:hover {
			background: #00ff00;
			color: #000;
		}

		.btn:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}

		.input {
			background: #2a2a2a;
			border: 1px solid #555;
			color: #00ff00;
			padding: 8px;
			margin: 5px;
			border-radius: 4px;
			font-family: inherit;
		}

		.status {
			margin: 10px 0;
			padding: 10px;
			background: #3a3a3a;
			border-radius: 4px;
		}

		.players-list {
			margin: 10px 0;
		}

		.player-item {
			padding: 5px 10px;
			margin: 2px 0;
			background: #3a3a3a;
			border-radius: 4px;
		}

		.error {
			color: #ff4444;
		}

		.success {
			color: #44ff44;
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="header">
			<h1>TRANSCENDENCE</h1>
			<div class="status" id="connectionStatus">Connecting...</div>
		</div>

		<div class="game-area">
			<div class="lobby-panel">
				<h3>Game Lobby</h3>
				
				<div class="controls">
					<h4>Create Room</h4>
					<input type="number" id="entryFee" class="input" placeholder="Entry Fee" value="0" min="0">
					<input type="number" id="maxPlayers" class="input" placeholder="Max Players" value="4" min="2" max="8">
					<button class="btn" id="createRoomBtn">Create Room</button>
				</div>

				<div class="controls">
					<h4>Available Rooms</h4>
					<button class="btn" id="refreshRoomsBtn">Refresh</button>
					<div class="room-list" id="roomList"></div>
				</div>

				<div id="currentRoom" style="display: none;">
					<h4>Current Room</h4>
					<div id="roomInfo"></div>
					<div class="players-list" id="playersList"></div>
					<div class="controls">
						<button class="btn" id="markReadyBtn" style="display: none;">Mark Ready</button>
						<button class="btn" id="markWaitingBtn" style="display: none;">Mark Waiting</button>
						<button class="btn" id="startGameBtn" style="display: none;">Start Game</button>
						<button class="btn" id="leaveRoomBtn">Leave Room</button>
					</div>
				</div>
			</div>

			<div class="game-canvas-container">
				<canvas id="gameCanvas" width="600" height="600"></canvas>
				<div class="overlay" id="gameOverlay"></div>
			</div>
		</div>
	</div>

	<script>
class GameClient {
	constructor() {
		this.canvas = document.getElementById('gameCanvas');
		this.ctx = this.canvas.getContext('2d');
		this.overlay = document.getElementById('gameOverlay');
		
		this.lobbyWs = null;
		this.gameWs = null;
		this.currentRoomId = null;
		this.isCreator = false;
		this.gameState = null;
		this.players = [];
		this.gameResults = null;
		this.accessToken = null;
		this.sessionId = null; // ‚Üê Changed from userId
		this.isInitialized = false;

		this.mouseX = 0;
		this.mouseY = 0;
		this.lastMouseUpdate = 0;
		
		// Get sessionId from parent, then initialize
		this.requestSessionIdFromParent();
		this.setupMessageListener();
	}

	setupMessageListener() {
		window.addEventListener('message', (event) => {
			if (event.origin !== window.location.origin) return;

			switch (event.data.type) {
				case 'SESSION_ID_RESPONSE':
					this.sessionId = event.data.sessionId;
					this.user = event.data.user;
					if (!this.isInitialized)
					   this.initializeAuth();
					break;
				
				case 'NOT_AUTHENTICATED':
					this.notifyParent('Authentication required', 'error');
					break;

				case 'USER_LOGGED_OUT': // New event from parent when user logs out
					console.log('User logged out, cleaning up...');
					this.handleAuthenticationLost();
					break;
			}
		});
	}

	requestSessionIdFromParent() {
		window.parent.postMessage({
			type: 'REQUEST_SESSION' // ‚Üê Changed from REQUEST_USER_ID
		}, window.location.origin);
	}

	async initializeAuth() {
		try {
			this.notifyParent('Getting authentication tokens...');
			
			// Since getTokens only reads from cookie, we don't need to pass sessionId
			const response = await fetch(`http://localhost:4000/api/users/tokens`, {
				method: 'GET',
				credentials: 'include' // ‚Üê Important for cookies
			});

			if (response.ok) {
				const data = await response.json();
				if (data.success) {
					this.accessToken = data.accessToken;
					this.isInitialized = true;
					this.notifyParent(`Authenticated as ${data.user.username}`, 'success');
					this.initializeWebSockets();
					this.setupEventListeners();
					this.startRenderLoop();
					
					// Notify parent that game is ready
					window.parent.postMessage({
						type: 'GAME_READY'
					}, window.location.origin);
					return;
				}
			}
			
			// Authentication failed
			this.notifyParent('Authentication failed', 'error');
			window.parent.postMessage({ type: 'AUTH_FAILED' }, window.location.origin);
			
		} catch (error) {
			console.error('Auth initialization failed:', error);
			this.notifyParent('Authentication error', 'error');
			window.parent.postMessage({ type: 'AUTH_FAILED' }, window.location.origin);
		}
	}

	initializeWebSockets() {
		console.log('Initializing WebSocket connections...');
		this.connectLobby();
	}

	notifyParent(message, type = 'info') {
		window.parent.postMessage({
			type: 'UPDATE_STATUS',
			message: message,
			type: type
		}, window.location.origin);
	}

	connectLobby() {
		if (this.lobbyWs) {
			this.lobbyWs.close();
		}

		// Use sessionId in WebSocket URL
		this.lobbyWs = new WebSocket(`ws://localhost:4000/ws/lobby?sId=${this.sessionId}`);
		
		this.lobbyWs.onopen = () => {
			this.updateStatus('Connected to lobby', 'success');
			this.notifyParent('Connected to game lobby', 'success');
			console.log('Lobby WebSocket connected');
		};

		this.lobbyWs.onmessage = (event) => {
			try {
				const data = JSON.parse(event.data);
				this.handleLobbyMessage(data);
			} catch (error) {
				console.error('Error parsing lobby message:', error);
			}
		};

		this.lobbyWs.onclose = () => {
			this.updateStatus('Disconnected from lobby', 'error');
			this.notifyParent('Disconnected from lobby', 'error');
			setTimeout(() => this.connectLobby(), 3000);
		};

		this.lobbyWs.onerror = (error) => {
			console.error('Lobby WebSocket error:', error);
			this.updateStatus('Lobby connection error', 'error');
			this.notifyParent('Lobby connection error', 'error');
		};
	}

	connectGame() {
		if (!this.currentRoomId) return;

		if (this.gameWs) {
			this.gameWs.close();
		}

		// Use sessionId in WebSocket URL
		this.gameWs = new WebSocket(`ws://localhost:4000/ws/game/${this.currentRoomId}?sId=${this.sessionId}`);
		
		this.gameWs.onopen = () => {
			console.log('Game WebSocket connected');
			this.notifyParent('Connected to game', 'success');
		};

		this.gameWs.onmessage = (event) => {
			try {
				const data = JSON.parse(event.data);
				this.handleGameMessage(data);
			} catch (error) {
				console.error('Error parsing game message:', error);
			}
		};

		this.gameWs.onclose = () => {
			console.log('Game WebSocket closed');
		};

		this.gameWs.onerror = (error) => {
			console.error('Game WebSocket error:', error);
		};
	}

	handleLobbyMessage(data) {
		if (data.userLeft) {
			this.showCurrentRoom(data.userLeft.room);  // ‚Üê Updates UI with new room state
			
			// Refresh room list to get updated state
			setTimeout(() => {
				if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
					this.lobbyWs.send('refresh');
				}
			}, 100);
		}

		// update room list
		if (data.rooms) {
			this.updateRoomList(data.rooms);
			this.currentRoomId = data.currentRoomId;
			
			// Update current room display if we're in a room
			if (this.currentRoomId) {
				const currentRoom = data.rooms.find(r => r.isCurrentRoom);
				if (currentRoom) {
					this.isCreator = currentRoom.isCreator;
					this.showCurrentRoom(currentRoom);

					if (!this.gameWs || this.gameWs.readyState !== WebSocket.OPEN) {
						console.log('Auto-reconnecting to game after page refresh');
						this.connectGame();
					}
				}
			}
		}

		// connect to a current game upon refresh
		if (data.success !== undefined) {
			if (data.success && data.roomId) {
				this.currentRoomId = data.roomId;
				this.isCreator = data.isCreator || false;
				this.showCurrentRoom(data.room);
				if (this.gameWs)
					this.connectGame();
				
				// Refresh room list to get updated state
				setTimeout(() => {
					if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
						this.lobbyWs.send('refresh');
				}
			}, 100);
			} else if (!data.success) {
				this.updateStatus(data.error || 'Operation failed', 'error');
			}
		}

		// handle join specifically
		if (data.userJoined) {
			this.showCurrentRoom(data.userJoined.room);  // ‚Üê Updates UI with new room state
			
			// Refresh room list to get updated state
			setTimeout(() => {
				if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
					this.lobbyWs.send('refresh');
				}
			}, 100);
		}

		// change room status
		if (data.roomStateChanged) {
			this.showCurrentRoom(data.roomStateChanged.room);
			this.updateStatus(`Room marked as ${data.roomStateChanged.newState}`, 'success');
			
			// Refresh room list to get updated state
			setTimeout(() => {
				if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
					this.lobbyWs.send('refresh');
				}
			}, 100);
		}
	}

	handleGameMessage(data) {
		console.log('Received game message:', data);

		if (data.type === 'gameFinished') {
			console.log('Game finished with results:', data.gameResult);
			this.gameState = { state: 'finished' };
			this.gameResults = data.gameResult;
			// Clear the map and show results
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
			this.showGameResults(data.gameResult);

			// Close game WebSocket and clear state
			if (this.gameWs) {
				this.gameWs.close();
				this.gameWs = null;
			}
			this.gameState = null;
		}
		else if ((data.state !== undefined || data.ballPosition !== undefined)) {
			this.gameState = data;
			console.log('Game state updated:', this.gameState);
		}
	}

	showGameResults(gameResult) {
		// Clear the canvas
		this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

		let resultsHtml = '<div style="background: rgba(0,0,0,0.9); padding: 20px; border-radius: 8px; color: white; max-width: 400px;">';
		resultsHtml += '<h2 style="color: #00ff00; text-align: center; margin-top: 0;">Game Results</h2>';

		// Sort players by place
		const sortedPlayers = [...gameResult.players].sort((a, b) => {
			if (a.place === '1') return -1;
			if (b.place === '1') return 1;
			return parseInt(a.place) - parseInt(b.place);
		});

		sortedPlayers.forEach((player, index) => {
			const placeEmoji = player.place === '1' ? 'üèÜ' : 
							player.place === '2' ? 'ü•à' : 
							player.place === '3' ? 'ü•â' : 'üìç';

			const statusColor = player.isActive ? '#00ff00' : '#ff4444';
			const underline = player.place === '1' ? 'text-decoration: underline;' : '';
			resultsHtml += `
				<div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 4px;">
					<span style="font-size: 20px;">${placeEmoji}</span>
					<strong style="color: ${statusColor}; ${underline}">${player.username}</strong>
					<br>
					<small>Place: ${player.place} | Players eliminated: ${player.playersKicked || 0}</small>
				</div>
			`;
		});

		resultsHtml += '</div>';
		this.overlay.innerHTML = resultsHtml;
	}

	showGameEndRedirectMessage() {
		const currentContent = this.overlay.innerHTML;
		this.overlay.innerHTML = currentContent + 
			'<div style="background: rgba(255,0,0,0.9); padding: 15px; margin-top: 20px; border-radius: 8px; text-align: center;">' +
			'<h3 style="margin: 0; color: white;">Session Expired</h3>' +
			'<p style="margin: 10px 0; color: white;">Your session has expired. You will be redirected to login in 10 seconds.</p>' +
			'<p style="margin: 0; color: white; font-size: 12px;">You can refresh the page to login again.</p>' +
			'</div>';
	}

	setupEventListeners() {
		// Create room
		document.getElementById('createRoomBtn').onclick = () => {
			const entryFee = parseInt(document.getElementById('entryFee').value) || 0;
			const maxPlayers = parseInt(document.getElementById('maxPlayers').value) || 4;
			this.createRoom(entryFee, maxPlayers);
		};

		// Refresh rooms
		document.getElementById('refreshRoomsBtn').onclick = () => {
			if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
				this.lobbyWs.send(JSON.stringify({ type: 'getRooms' }));
			}
		};

		// Leave room
		document.getElementById('leaveRoomBtn').onclick = () => {
			this.leaveRoom();
		};

		// Start game
		document.getElementById('startGameBtn').onclick = () => {
			this.startGame();
		};

		// Mark room ready
		document.getElementById('markReadyBtn').onclick = () => {
			this.markRoomReady();
		};

		// Mark room waiting
		document.getElementById('markWaitingBtn').onclick = () => {
			this.markRoomWaiting();
		};

		// Mouse movement for game - only when game is actually playing
		this.canvas.addEventListener('mousemove', (e) => {
			const rect = this.canvas.getBoundingClientRect();
			const newMouseX = (e.clientX - rect.left) / rect.width;

			// Calculate drag delta
			const dragDelta = newMouseX - this.mouseX;
			this.mouseX = newMouseX;

			// Only send input if game is in playing state
			if (!this.gameState || this.gameState.state !== 'playing') {
				return;
			}

			// Only send if game WebSocket is ready and delta is meaningful
			if (this.gameWs && this.gameWs.readyState === WebSocket.OPEN && Math.abs(dragDelta) > 0.001) {
				// Send drag delta (scaled for sensitivity)
				if (this.gameState.players.length == 2)
					this.gameWs.send((dragDelta * 1000).toString());
				else
					this.gameWs.send((dragDelta * 500).toString());
			}
		});
	}

	createRoom(entryFee, maxPlayers) {
		const ws = new WebSocket(`ws://localhost:4000/ws/room/create?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send(JSON.stringify({ entryFee, maxPlayers }));
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			this.handleLobbyMessage(data);
			ws.close();
		};

		ws.onerror = (event) => {
			console.log(event.data)
		}
	}

	joinRoom(roomId) {
		const ws = new WebSocket(`ws://localhost:4000/ws/room/join?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send(JSON.stringify({ roomId }));
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			this.handleLobbyMessage(data);
			ws.close();
		};

		ws.onerror = (event) => {
			console.log(event.data)
		}
	}

	leaveRoom() {
		if (!this.currentRoomId) return;

		const ws = new WebSocket(`ws://localhost:4000/ws/room/leave?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send(JSON.stringify({ roomId: this.currentRoomId }));
			this.currentRoomId = null;
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.success) {
				this.currentRoomId = null;
				this.isCreator = false;
				this.hideCurrentRoom();
				if (this.gameWs) {
					this.gameWs.close();
					this.gameWs = null;
				}
			}
			this.handleLobbyMessage(data);
			ws.close();
		};

		ws.onerror = (event) => {
			console.log(event.data)
		}
	}

	startGame() {
		if (!this.currentRoomId) return;

		const ws = new WebSocket(`ws://localhost:4000/ws/game/${this.currentRoomId}/start?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send('start');
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.success) {
				this.updateStatus('Game started!', 'success');
			} else {
				this.updateStatus(data.error || 'Failed to start game', 'error');
			}
			ws.close();
		};
	}

	markRoomReady() {
		if (!this.currentRoomId) return;

		const ws = new WebSocket(`ws://localhost:4000/ws/room/markReady?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send('ready');
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.success) {
				this.updateStatus('Room marked as ready', 'success');
				// Refresh the lobby to get updated room state
				if (this.lobbyWs && this.lobbyWs.readyState === WebSocket.OPEN) {
					this.lobbyWs.send('refresh');
				}
			} else {
				this.updateStatus(data.error || 'Failed to mark room as ready', 'error');
			}
			ws.close();
		};
	}

	markRoomWaiting() {
		if (!this.currentRoomId) return;

		// Use dedicated endpoint - no room ID needed, server determines it
		const ws = new WebSocket(`ws://localhost:4000/ws/room/markWaiting?sId=${this.sessionId}`);
		
		ws.onopen = () => {
			ws.send('waiting'); // Simple message, server validates everything
		};

		ws.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.success) {
				this.updateStatus('Room marked as waiting', 'success');
			} else {
				this.updateStatus(data.error || 'Failed to mark room as waiting', 'error');
			}
			ws.close();
		};
	}

	updateRoomList(rooms) {
		const roomList = document.getElementById('roomList');
		roomList.innerHTML = '';

		rooms.forEach(room => {
			const roomEl = document.createElement('div');
			roomEl.className = 'room-item';
			if (room.isCurrentRoom) {
				roomEl.classList.add('current');
			}

			roomEl.innerHTML = `
				<div><strong>Room ${room.id.substring(0, 8)}</strong></div>
				<div>Players: ${room.players.length}/${room.maxPlayers}</div>
				<div>Entry Fee: ${room.entryFee}</div>
				<div>State: ${room.state}</div>
				<div>Creator: ${room.creatorUsername}</div>
			`;

			if (!room.isCurrentRoom && room.state === 'waiting' && room.players.length < room.maxPlayers) {
				roomEl.onclick = () => this.joinRoom(room.id);
			}

			roomList.appendChild(roomEl);
		});
	}

	showCurrentRoom(room) {
		if (!room) return;

		document.getElementById('currentRoom').style.display = 'block';
		
		const roomInfo = document.getElementById('roomInfo');
		roomInfo.innerHTML = `
			<div><strong>Room ID:</strong> ${room.id.substring(0, 8)}</div>
			<div><strong>Entry Fee:</strong> ${room.entryFee}</div>
			<div><strong>Max Players:</strong> ${room.maxPlayers}</div>
			<div><strong>State:</strong> ${room.state}</div>
		`;

		const playersList = document.getElementById('playersList');
		playersList.innerHTML = '<h5>Players:</h5>';
		room.players.forEach(player => {
			const playerEl = document.createElement('div');
			playerEl.className = 'player-item';
			playerEl.textContent = player.username;
			playersList.appendChild(playerEl);
		});

		// Show appropriate buttons for creator
		const markReadyBtn = document.getElementById('markReadyBtn');
		const markWaitingBtn = document.getElementById('markWaitingBtn');
		const startBtn = document.getElementById('startGameBtn');
		
		console.log('Button logic check:', {
			isCreator: this.isCreator,
			roomState: room.state,
			playerCount: room.players.length,
			hasEnoughPlayers: room.players.length >= 2
		});
		
		if (this.isCreator) {
			if (room.state === 'waiting' && room.players.length >= 2) {
				// Show "Mark Ready" button when waiting with enough players
				markReadyBtn.style.display = 'inline-block';
				markWaitingBtn.style.display = 'none';
				startBtn.style.display = 'none';
				console.log('Showing Mark Ready button');
			} else if (room.state === 'ready') {
				// Show "Mark Waiting" and "Start Game" buttons when ready
				markReadyBtn.style.display = 'none';
				markWaitingBtn.style.display = 'inline-block';
				startBtn.style.display = 'inline-block';
				console.log('Showing Mark Waiting and Start Game buttons');
			} else {
				// Hide all buttons when not enough players or other states
				markReadyBtn.style.display = 'none';
				markWaitingBtn.style.display = 'none';
				startBtn.style.display = 'none';
				console.log('Hiding all buttons - not enough players or wrong state');
			}
		} else {
			// Non-creators see no buttons
			markReadyBtn.style.display = 'none';
			markWaitingBtn.style.display = 'none';
			startBtn.style.display = 'none';
			console.log('Hiding all buttons - not creator');
		}
	}

	hideCurrentRoom() {
		document.getElementById('currentRoom').style.display = 'none';
		this.gameState = null;
		this.overlay.innerHTML = '';
	}

	updateStatus(message, type = '') {
		const status = document.getElementById('connectionStatus');
		status.textContent = message;
		status.className = `status ${type}`;
	}

	startRenderLoop() {
		const render = () => {
			this.renderGame();
			requestAnimationFrame(render);
		};
		render();
	}

	renderGame() {
		const ctx = this.ctx;
		const canvas = this.canvas;
		
		// Clear canvas
		ctx.fillStyle = '#000';
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		if (!this.gameState) {
			// Draw empty arena
			this.drawArena(ctx, canvas);
			return;
		}

		// Draw arena
		this.drawArena(ctx, canvas);

		// Draw ball
		if (this.gameState.ballPosition) {
			this.drawBall(ctx, canvas, this.gameState.ballPosition);
		}

		// Draw players
		if (this.gameState.players) {
			this.drawPlayers(ctx, canvas, this.gameState.players);
		}
	}

	drawArena(ctx, canvas) {
		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;
		const radius = 300;

		// Check if we're in 2-player mode for square arena
		if (this.gameState && this.gameState.players && this.gameState.players.length === 2) {
			// Draw square arena for 2-player mode
			ctx.strokeStyle = '#00ff00';
			ctx.lineWidth = 3;
			ctx.beginPath();
			ctx.rect(centerX - radius, centerY - radius * 0.5, radius * 2, radius);
			ctx.stroke();
		} else {
			// Draw circular arena for multi-player mode
			ctx.strokeStyle = '#00ff00';
			ctx.lineWidth = 3;
			ctx.beginPath();
			ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
			ctx.stroke();
		}

		// Draw center dot
		ctx.fillStyle = '#00ff00';
		ctx.beginPath();
		ctx.arc(centerX, centerY, 3, 0, Math.PI * 2);
		ctx.fill();
	}

	drawBall(ctx, canvas, ballPos) {
		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;
		const radius = 300;

		const ballX = centerX + ballPos[0] * radius;
		const ballY = centerY + ballPos[1] * radius;

		ctx.fillStyle = '#ffffff';
		ctx.beginPath();
		ctx.arc(ballX, ballY, 8, 0, Math.PI * 2);
		ctx.fill();
	}

	drawPlayers(ctx, canvas, players) {
		if (!players || players.length === 0) {
			console.log('No players to draw');
			return;
		}

		const centerX = canvas.width / 2;
		const centerY = canvas.height / 2;
		const radius = 300;

		// Special case for 2 players - use left/right virtual positions (x = -1 and x = 1)
		if (players.length === 2) {
			const paddleWidth = 0.1;
			
			players.forEach((player, index) => {
				// Apply server-side logic: calculateTwoPlayersPositions
				const playerDist = player.position - 0.5;
				let virtualX, virtualY;
				
				if (index === 0) {
					// Left player
					virtualX = -1;
					virtualY = playerDist;
				} else {
					// Right player
					virtualX = 1;
					virtualY = playerDist;
				}

				// Map virtual coords to screen (paddle center)
				const screenX = centerX + virtualX * radius;
				const screenY = centerY + virtualY * radius;

				// Calculate paddle endpoints (vertical paddle)
				const paddleHalfLength = paddleWidth * radius;
				const leftX = screenX;
				const leftY = screenY - paddleHalfLength;
				const rightX = screenX;
				const rightY = screenY + paddleHalfLength;
				
				// Draw paddle using moveTo/lineTo pattern
				ctx.strokeStyle = player.isActive ? '#00ff00' : '#ff4444';
				ctx.lineWidth = 6;
				ctx.beginPath();
				ctx.moveTo(leftX, leftY);
				ctx.lineTo(rightX, rightY);
				ctx.stroke();

				// Draw player name
				ctx.fillStyle = player.isActive ? '#00ff00' : '#ff4444';
				ctx.font = '12px Courier New';
				ctx.textAlign = 'center';
				ctx.fillText(player.username, screenX, screenY - paddleHalfLength - 10);
			});
			return;
		}

		// Original multi-player circular arrangement
		const playerCount = players.length;
		const alpha = (Math.PI * 2) / playerCount;
		const height = 0.5 / Math.tan(alpha / 2);
		const paddleWidth = 0.1;

		players.forEach((player, index) => {
			const beta = alpha * index;
			const gamma = beta - (Math.PI / 2);

			// Calculate paddle position
			const distance = player.position - 0.5;
			const distance_x = distance * Math.cos(beta);
			const distance_y = distance * Math.sin(beta);
			const x_center = height * Math.cos(gamma);
			const y_center = height * Math.sin(gamma);
			const paddleX = x_center + distance_x;
			const paddleY = y_center + distance_y;

			// Draw paddle
			const screenX = centerX + paddleX * radius;
			const screenY = centerY + paddleY * radius;

			const leftX = screenX - paddleWidth * Math.cos(beta) * radius;
			const leftY = screenY - paddleWidth * Math.sin(beta) * radius;
			const rightX = screenX + paddleWidth * Math.cos(beta) * radius;
			const rightY = screenY + paddleWidth * Math.sin(beta) * radius;

			ctx.strokeStyle = player.isActive ? '#00ff00' : '#ff4444';
			ctx.lineWidth = 6;
			ctx.beginPath();
			ctx.moveTo(leftX, leftY);
			ctx.lineTo(rightX, rightY);
			ctx.stroke();

			// Draw player name
			ctx.fillStyle = player.isActive ? '#00ff00' : '#ff4444';
			ctx.font = '12px Courier New';
			ctx.textAlign = 'center';
			ctx.fillText(player.username, screenX, screenY - 20);
		});
	}

	handleAuthenticationLost() {
		console.log('Authentication lost, cleaning up...');
		
		// Close connections
		if (this.lobbyWs) {
			this.lobbyWs.close(1000, 'Authentication lost');
			this.lobbyWs = null;
		}
		if (this.gameWs) {
			this.gameWs.close(1000, 'Authentication lost');
			this.gameWs = null;
		}
		
		// Clear state
		this.sessionId = null;
		this.accessToken = null;
		this.currentRoomId = null;
		this.isCreator = false;
		this.gameState = null;
		this.isInitialized = false;
		
		// Update UI
		this.hideCurrentRoom();
		this.updateStatus('Authentication required', 'error');
		this.notifyParent('Please log in to play', 'error');
		
		// Clear room list
		document.getElementById('roomList').innerHTML = '';
		this.overlay.innerHTML = '<div style="text-align: center; color: #ff4444;">Please log in to play</div>';
	}
}

// Initialize the game client when page loads
window.addEventListener('load', () => {
	new GameClient();
});
	</script>
</body>
</html>